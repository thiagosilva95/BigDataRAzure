r + r
2 + 2
3 + 3
setwd("D:/codes/R/dsa/BigDataRAzure/Cap07")
getwd()
# Instalando os pacotes
install.packages("data.table")
library(data.table)
?data.table
# Criando 2 vetores
vec1 <- c(1, 2, 3, 4)
vec2 <- c("Vermelho", "Verde", "Marrom", "Laranja")
# Criando um data.table
dt1 <- data.table(vec1, vec2)
dt1
class(dt1)
# Slicing do data.table
dt2 <- data.table(A = 1:9, B = c("Z", "W", "Q"), C = rnorm(9), D = TRUE)
dt2
dt2[3:5,]
dt2[,.(B, C)]
# Aplicando função ao data.table
dt2[, .(Total = sum(A), Mean = mean(C))]
dt2[, plot(A, C)]
dt2[, .(MySum = sum(A), by = .(Grp = A%%2)]
dt2[, .(MySum = sum(A)), by = .(Grp = A%%2)]
# Definindo valores por grupo
dt3 <- data.table(B = c("a", "b", "c", "d", "e", "a", "b", "c", "d", "e"),
val = as.integer(c(6:10, 1:5)))
dt3
# Operações com data.tables
dt4 <- data.table(A = rep(letters[2:1], each = 4L),
B = rep(1:4, each = 2L),
C = sample(8))
dt4
new_dt4 <- dt4[, sum(C), by = A]
class(new_dt4)
new_dt4
shape(new_dt4)
str(new_dt4)
new_dt4[order(A)]
new_dt4 <- dt4[, sum(B), by = A][order(A)]
new_dt4
# Iris
dt5 <- as.data.frame(iris)
dt5
View(dt5)
dt5[, .(Sepal.Length = median(Sepel.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
dt5[, .(Sepal.Length = median(Sepel.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
dt5[, .(Sepal.Length = median(Sepal.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
dt5[, .(Sepal.Length = median(Sepal.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
dt5[, .(Sepal.Length = median(Sepal.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
# O parâmetro .SD significa Subset Data e um subset é criado considerando a coluna Species e depois
# é calculda a mediana. O resultado deve ser igual ao comando anterior.
# O .SD faz parte da notação do pacote data.table.
dt5[, lapply(.SD, median), by = Species]
# O parâmetro .SD significa Subset Data e um subset é criado considerando a coluna Species e depois
# é calculda a mediana. O resultado deve ser igual ao comando anterior.
# O .SD faz parte da notação do pacote data.table.
dt5[, lapply(.SD, median), by = Species]
data.frame()
?data.table
View(dt5)
dt5[, .(Sepal.Length = median(Sepal.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
dt5[, .(Sepal.Length = median(Sepal.Length),
Sepal.Width = median(Sepal.Width),
Petal.Length = median(Petal.Length),
Petal.Width = median(Petal.Width)),
by = Species]
setwd("D:/codes/R/dsa/BigDataRAzure/Cap07")
getwd()
# Vetores
x <- c("A", "E", "D", "B", "C")
x[]
x
# Índices positivos - Elementos em posições específicas
x[c(1, 3)]
x[c(1, 1)]
x[order(x)]
# Índices negativos - Ignora elementos em posições específicas
x[-c(1, 3)]
x[-c(1, 4)]
# Vetor lógico
x
x[c(TRUE, FALSE)]
x[c(TRUE, FALSE, TRUE, FALSE)]
# Vetor de caracteres
y <- setNames(x, letters1:4)
# Vetor de caracteres
y <- setNames(x, letters[1:4])
y
y[c("d", "c", "a")]
y[c("a", "a", "a")]
# Vetor de caracteres
y <- setNames(x, letters[1:4])
y
# Vetor de caracteres
x <- c("A", "B", "C", "D")
y <- setNames(x, letters[1:4])
y
y[c("d", "c", "a")]
y[c("a", "a", "a")]
# Função outer() permite que uma matriz se comporte como vetores individuais
?outer
# Matrizes
mat - matrix(1:9, nrow = 3)
# Matrizes
mat <- matrix(1:9, nrow = 3)
mat
colnames(mat) <- c("A", "B", "C")
mat
mat[1:2, ]
mat[1:2, 2:3]
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals
vals[c(4, 15)]
# Data.frame
df <- data.frame(x = 1:3, y=3:1, Z = letters[1:3])
df
df$x
df[df$x == 2,]
df[c(1, 3), ]
df[c("x", "z")]
df[c("x", "z"), ]
str(df["x"])
df
# Removendo colunas de dataframes
df <- data.frame(x = 1:3, y=3:1, Z = letters[1:3])
df
df$z
# Removendo colunas de dataframes
df <- data.frame(x = 1:3, y=3:1, Z = letters[1:3])
df
df$z
df$z
df
df$z
df$Z
df$Z <- NULL
df
# Operadores [], [[]], e $
a <- list(x = 1:3, y = 4:5)
a
a
a[1]
a[[a]]
a[[1]]
a[1]
a[[1]]
a[[1]][[1]]
a[["x"]]
b <- list(a = list(b = list(c = list(d = 1))))
b
b[[c("a", "b", "c", "d")]]
b[["a"]][["b"]][["c"]][["d"]]
# x$y é equivalente a x[["y", exact = FALSE]]
var <- "cyl"
mtcars$var
mtcars[["var"]]
mtcars[[var]]
x <- list(abc = 1)
x
x$a
x[["a"]]
x[["abc"]]
# Substring e atribuição
x <- 1:5
x
x
x[c(1, 2)]
x[c(1, 2)] < c(2, 3)
x[c(1, 2)] < 2:3
x[c(1, 2)] <- 2:3
x
x[-1] <- 4:1
x
# Isso é subsetting
head(mtcars)
mtcars[] <- lapply(mtcars, as.integer)
head(mtcars)
# Isso não é subsetting
mtcars <- lapply(mtcars, as.integer)
head(mtcars)
# Lookup tables
x <- c("m", "f", "u", "f", "f", "m", "m")
x
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
# Lookup tables
x <- c("m", "f", "u", "f", "f", "m", "m")
x
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
unname(lookup[x])
intersect(x2, y2)
# Usando operadores lógicos
x1 <- 1:10 %% 2 == 0
x1
which(x1)
x2 <- which(x1)
x2
y1 <- 1:10 %% 5 == 0
y2 <- which(y1)
y2
intersect(x2, y2)
x1 & y1
union(x2, y2)
setdiff(x2, y2)
